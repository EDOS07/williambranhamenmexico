"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-aria+landmark@3.0.0-_f90490d25b8a5a1337736bb8646e00c1";
exports.ids = ["vendor-chunks/@react-aria+landmark@3.0.0-_f90490d25b8a5a1337736bb8646e00c1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-aria+landmark@3.0.0-_f90490d25b8a5a1337736bb8646e00c1/node_modules/@react-aria/landmark/dist/useLandmark.mjs":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-aria+landmark@3.0.0-_f90490d25b8a5a1337736bb8646e00c1/node_modules/@react-aria/landmark/dist/useLandmark.mjs ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLandmarkController: () => (/* binding */ $a86207c5d7f7e1fb$export$f50151dbd51cd1d9),\n/* harmony export */   useLandmark: () => (/* binding */ $a86207c5d7f7e1fb$export$4cc632584fd87fae)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.2.4_@babel+core@7.2_16ce3abb760b473ba98db4731cd0a223/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/.pnpm/@react-aria+utils@3.28.0_re_27f1ca34ebe419349921104e45bff3b6/node_modules/@react-aria/utils/dist/useLayoutEffect.mjs\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/.pnpm/use-sync-external-store@1.5.0_react@19.1.0/node_modules/use-sync-external-store/shim/index.js\");\n\n\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n// Increment this version number whenever the\n// LandmarkManagerApi or Landmark interfaces change.\nconst $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION = 1;\n// Symbol under which the singleton landmark manager instance is attached to the document.\nconst $a86207c5d7f7e1fb$var$landmarkSymbol = Symbol.for('react-aria-landmark-manager');\nfunction $a86207c5d7f7e1fb$var$subscribe(fn) {\n    document.addEventListener('react-aria-landmark-manager-change', fn);\n    return ()=>document.removeEventListener('react-aria-landmark-manager-change', fn);\n}\nfunction $a86207c5d7f7e1fb$var$getLandmarkManager() {\n    if (typeof document === 'undefined') return null;\n    // Reuse an existing instance if it has the same or greater version.\n    let instance = document[$a86207c5d7f7e1fb$var$landmarkSymbol];\n    if (instance && instance.version >= $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION) return instance;\n    // Otherwise, create a new instance and dispatch an event so anything using the existing\n    // instance updates and re-registers their landmarks with the new one.\n    document[$a86207c5d7f7e1fb$var$landmarkSymbol] = new $a86207c5d7f7e1fb$var$LandmarkManager();\n    document.dispatchEvent(new CustomEvent('react-aria-landmark-manager-change'));\n    return document[$a86207c5d7f7e1fb$var$landmarkSymbol];\n}\n// Subscribes a React component to the current landmark manager instance.\nfunction $a86207c5d7f7e1fb$var$useLandmarkManager() {\n    return (0, use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)($a86207c5d7f7e1fb$var$subscribe, $a86207c5d7f7e1fb$var$getLandmarkManager, $a86207c5d7f7e1fb$var$getLandmarkManager);\n}\nclass $a86207c5d7f7e1fb$var$LandmarkManager {\n    setupIfNeeded() {\n        if (this.isListening) return;\n        document.addEventListener('keydown', this.f6Handler, {\n            capture: true\n        });\n        document.addEventListener('focusin', this.focusinHandler, {\n            capture: true\n        });\n        document.addEventListener('focusout', this.focusoutHandler, {\n            capture: true\n        });\n        this.isListening = true;\n    }\n    teardownIfNeeded() {\n        if (!this.isListening || this.landmarks.length > 0 || this.refCount > 0) return;\n        document.removeEventListener('keydown', this.f6Handler, {\n            capture: true\n        });\n        document.removeEventListener('focusin', this.focusinHandler, {\n            capture: true\n        });\n        document.removeEventListener('focusout', this.focusoutHandler, {\n            capture: true\n        });\n        this.isListening = false;\n    }\n    focusLandmark(landmark, direction) {\n        var _this_landmarks_find_focus, _this_landmarks_find;\n        (_this_landmarks_find = this.landmarks.find((l)=>l.ref.current === landmark)) === null || _this_landmarks_find === void 0 ? void 0 : (_this_landmarks_find_focus = _this_landmarks_find.focus) === null || _this_landmarks_find_focus === void 0 ? void 0 : _this_landmarks_find_focus.call(_this_landmarks_find, direction);\n    }\n    /**\n   * Return set of landmarks with a specific role.\n   */ getLandmarksByRole(role) {\n        return new Set(this.landmarks.filter((l)=>l.role === role));\n    }\n    /**\n   * Return first landmark with a specific role.\n   */ getLandmarkByRole(role) {\n        return this.landmarks.find((l)=>l.role === role);\n    }\n    addLandmark(newLandmark) {\n        this.setupIfNeeded();\n        if (this.landmarks.find((landmark)=>landmark.ref === newLandmark.ref) || !newLandmark.ref.current) return;\n        if (this.landmarks.filter((landmark)=>landmark.role === 'main').length > 1) console.error('Page can contain no more than one landmark with the role \"main\".');\n        if (this.landmarks.length === 0) {\n            this.landmarks = [\n                newLandmark\n            ];\n            this.checkLabels(newLandmark.role);\n            return;\n        }\n        // Binary search to insert new landmark based on position in document relative to existing landmarks.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        let start = 0;\n        let end = this.landmarks.length - 1;\n        while(start <= end){\n            let mid = Math.floor((start + end) / 2);\n            let comparedPosition = newLandmark.ref.current.compareDocumentPosition(this.landmarks[mid].ref.current);\n            let isNewAfterExisting = Boolean(comparedPosition & Node.DOCUMENT_POSITION_PRECEDING || comparedPosition & Node.DOCUMENT_POSITION_CONTAINS);\n            if (isNewAfterExisting) start = mid + 1;\n            else end = mid - 1;\n        }\n        this.landmarks.splice(start, 0, newLandmark);\n        this.checkLabels(newLandmark.role);\n    }\n    updateLandmark(landmark) {\n        let index = this.landmarks.findIndex((l)=>l.ref === landmark.ref);\n        if (index >= 0) {\n            this.landmarks[index] = {\n                ...this.landmarks[index],\n                ...landmark\n            };\n            this.checkLabels(this.landmarks[index].role);\n        }\n    }\n    removeLandmark(ref) {\n        this.landmarks = this.landmarks.filter((landmark)=>landmark.ref !== ref);\n        this.teardownIfNeeded();\n    }\n    /**\n   * Warn if there are 2+ landmarks with the same role but no label.\n   * Labels for landmarks with the same role must also be unique.\n   *\n   * See https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/.\n   */ checkLabels(role) {\n        let landmarksWithRole = this.getLandmarksByRole(role);\n        if (landmarksWithRole.size > 1) {\n            let duplicatesWithoutLabel = [\n                ...landmarksWithRole\n            ].filter((landmark)=>!landmark.label);\n            if (duplicatesWithoutLabel.length > 0) console.warn(`Page contains more than one landmark with the '${role}' role. If two or more landmarks on a page share the same role, all must be labeled with an aria-label or aria-labelledby attribute: `, duplicatesWithoutLabel.map((landmark)=>landmark.ref.current));\n            else {\n                let labels = [\n                    ...landmarksWithRole\n                ].map((landmark)=>landmark.label);\n                let duplicateLabels = labels.filter((item, index)=>labels.indexOf(item) !== index);\n                duplicateLabels.forEach((label)=>{\n                    console.warn(`Page contains more than one landmark with the '${role}' role and '${label}' label. If two or more landmarks on a page share the same role, they must have unique labels: `, [\n                        ...landmarksWithRole\n                    ].filter((landmark)=>landmark.label === label).map((landmark)=>landmark.ref.current));\n                });\n            }\n        }\n    }\n    /**\n   * Get the landmark that is the closest parent in the DOM.\n   * Returns undefined if no parent is a landmark.\n   */ closestLandmark(element) {\n        let landmarkMap = new Map(this.landmarks.map((l)=>[\n                l.ref.current,\n                l\n            ]));\n        let currentElement = element;\n        while(currentElement && !landmarkMap.has(currentElement) && currentElement !== document.body && currentElement.parentElement)currentElement = currentElement.parentElement;\n        return landmarkMap.get(currentElement);\n    }\n    /**\n   * Gets the next landmark, in DOM focus order, or previous if backwards is specified.\n   * If last landmark, next should be the first landmark.\n   * If not inside a landmark, will return first landmark.\n   * Returns undefined if there are no landmarks.\n   */ getNextLandmark(element, { backward: backward }) {\n        var _this_landmarks_nextLandmarkIndex_ref_current;\n        let currentLandmark = this.closestLandmark(element);\n        let nextLandmarkIndex = backward ? this.landmarks.length - 1 : 0;\n        if (currentLandmark) nextLandmarkIndex = this.landmarks.indexOf(currentLandmark) + (backward ? -1 : 1);\n        let wrapIfNeeded = ()=>{\n            // When we reach the end of the landmark sequence, fire a custom event that can be listened for by applications.\n            // If this event is canceled, we return immediately. This can be used to implement landmark navigation across iframes.\n            if (nextLandmarkIndex < 0) {\n                if (!element.dispatchEvent(new CustomEvent('react-aria-landmark-navigation', {\n                    detail: {\n                        direction: 'backward'\n                    },\n                    bubbles: true,\n                    cancelable: true\n                }))) return true;\n                nextLandmarkIndex = this.landmarks.length - 1;\n            } else if (nextLandmarkIndex >= this.landmarks.length) {\n                if (!element.dispatchEvent(new CustomEvent('react-aria-landmark-navigation', {\n                    detail: {\n                        direction: 'forward'\n                    },\n                    bubbles: true,\n                    cancelable: true\n                }))) return true;\n                nextLandmarkIndex = 0;\n            }\n            if (nextLandmarkIndex < 0 || nextLandmarkIndex >= this.landmarks.length) return true;\n            return false;\n        };\n        if (wrapIfNeeded()) return undefined;\n        // Skip over hidden landmarks.\n        let i = nextLandmarkIndex;\n        while((_this_landmarks_nextLandmarkIndex_ref_current = this.landmarks[nextLandmarkIndex].ref.current) === null || _this_landmarks_nextLandmarkIndex_ref_current === void 0 ? void 0 : _this_landmarks_nextLandmarkIndex_ref_current.closest('[aria-hidden=true]')){\n            nextLandmarkIndex += backward ? -1 : 1;\n            if (wrapIfNeeded()) return undefined;\n            if (nextLandmarkIndex === i) break;\n        }\n        return this.landmarks[nextLandmarkIndex];\n    }\n    /**\n   * Look at next landmark. If an element was previously focused inside, restore focus there.\n   * If not, focus the landmark itself.\n   * If no landmarks at all, or none with focusable elements, don't move focus.\n   */ f6Handler(e) {\n        if (e.key === 'F6') {\n            // If alt key pressed, focus main landmark, otherwise navigate forward or backward based on shift key.\n            let handled = e.altKey ? this.focusMain() : this.navigate(e.target, e.shiftKey);\n            if (handled) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n    }\n    focusMain() {\n        let main = this.getLandmarkByRole('main');\n        if (main && main.ref.current && document.contains(main.ref.current)) {\n            this.focusLandmark(main.ref.current, 'forward');\n            return true;\n        }\n        return false;\n    }\n    navigate(from, backward) {\n        let nextLandmark = this.getNextLandmark(from, {\n            backward: backward\n        });\n        if (!nextLandmark) return false;\n        // If something was previously focused in the next landmark, then return focus to it\n        if (nextLandmark.lastFocused) {\n            let lastFocused = nextLandmark.lastFocused;\n            if (document.body.contains(lastFocused)) {\n                lastFocused.focus();\n                return true;\n            }\n        }\n        // Otherwise, focus the landmark itself\n        if (nextLandmark.ref.current && document.contains(nextLandmark.ref.current)) {\n            this.focusLandmark(nextLandmark.ref.current, backward ? 'backward' : 'forward');\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Sets lastFocused for a landmark, if focus is moved within that landmark.\n   * Lets the last focused landmark know it was blurred if something else is focused.\n   */ focusinHandler(e) {\n        let currentLandmark = this.closestLandmark(e.target);\n        if (currentLandmark && currentLandmark.ref.current !== e.target) this.updateLandmark({\n            ref: currentLandmark.ref,\n            lastFocused: e.target\n        });\n        let previousFocusedElement = e.relatedTarget;\n        if (previousFocusedElement) {\n            let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n            if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();\n        }\n    }\n    /**\n   * Track if the focus is lost to the body. If it is, do cleanup on the landmark that last had focus.\n   */ focusoutHandler(e) {\n        let previousFocusedElement = e.target;\n        let nextFocusedElement = e.relatedTarget;\n        // the === document seems to be a jest thing for focus to go there on generic blur event such as landmark.blur();\n        // browsers appear to send focus instead to document.body and the relatedTarget is null when that happens\n        if (!nextFocusedElement || nextFocusedElement === document) {\n            let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n            if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();\n        }\n    }\n    createLandmarkController() {\n        let instance = this;\n        instance.refCount++;\n        instance.setupIfNeeded();\n        return {\n            navigate (direction, opts) {\n                let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n                return instance.navigate(element, direction === 'backward');\n            },\n            focusNext (opts) {\n                let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n                return instance.navigate(element, false);\n            },\n            focusPrevious (opts) {\n                let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n                return instance.navigate(element, true);\n            },\n            focusMain () {\n                return instance.focusMain();\n            },\n            dispose () {\n                if (instance) {\n                    instance.refCount--;\n                    instance.teardownIfNeeded();\n                    instance = null;\n                }\n            }\n        };\n    }\n    registerLandmark(landmark) {\n        if (this.landmarks.find((l)=>l.ref === landmark.ref)) this.updateLandmark(landmark);\n        else this.addLandmark(landmark);\n        return ()=>this.removeLandmark(landmark.ref);\n    }\n    constructor(){\n        this.landmarks = [];\n        this.isListening = false;\n        this.refCount = 0;\n        this.version = $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION;\n        this.f6Handler = this.f6Handler.bind(this);\n        this.focusinHandler = this.focusinHandler.bind(this);\n        this.focusoutHandler = this.focusoutHandler.bind(this);\n    }\n}\nfunction $a86207c5d7f7e1fb$export$f50151dbd51cd1d9() {\n    // Get the current landmark manager and create a controller using it.\n    let instance = $a86207c5d7f7e1fb$var$getLandmarkManager();\n    let controller = instance === null || instance === void 0 ? void 0 : instance.createLandmarkController();\n    let unsubscribe = $a86207c5d7f7e1fb$var$subscribe(()=>{\n        // If the landmark manager changes, dispose the old\n        // controller and create a new one.\n        controller === null || controller === void 0 ? void 0 : controller.dispose();\n        instance = $a86207c5d7f7e1fb$var$getLandmarkManager();\n        controller = instance === null || instance === void 0 ? void 0 : instance.createLandmarkController();\n    });\n    // Return a wrapper that proxies requests to the current controller instance.\n    return {\n        navigate (direction, opts) {\n            return controller.navigate(direction, opts);\n        },\n        focusNext (opts) {\n            return controller.focusNext(opts);\n        },\n        focusPrevious (opts) {\n            return controller.focusPrevious(opts);\n        },\n        focusMain () {\n            return controller.focusMain();\n        },\n        dispose () {\n            controller === null || controller === void 0 ? void 0 : controller.dispose();\n            unsubscribe();\n            controller = undefined;\n            instance = null;\n        }\n    };\n}\nfunction $a86207c5d7f7e1fb$export$4cc632584fd87fae(props, ref) {\n    const { role: role, 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledby, focus: focus } = props;\n    let manager = $a86207c5d7f7e1fb$var$useLandmarkManager();\n    let label = ariaLabel || ariaLabelledby;\n    let [isLandmarkFocused, setIsLandmarkFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let defaultFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setIsLandmarkFocused(true);\n    }, [\n        setIsLandmarkFocused\n    ]);\n    let blur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setIsLandmarkFocused(false);\n    }, [\n        setIsLandmarkFocused\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        if (manager) return manager.registerLandmark({\n            ref: ref,\n            label: label,\n            role: role,\n            focus: focus || defaultFocus,\n            blur: blur\n        });\n    }, [\n        manager,\n        label,\n        ref,\n        role,\n        focus,\n        defaultFocus,\n        blur\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _ref_current;\n        if (isLandmarkFocused) (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();\n    }, [\n        isLandmarkFocused,\n        ref\n    ]);\n    return {\n        landmarkProps: {\n            role: role,\n            tabIndex: isLandmarkFocused ? -1 : undefined,\n            'aria-label': ariaLabel,\n            'aria-labelledby': ariaLabelledby\n        }\n    };\n}\n\n\n\n//# sourceMappingURL=useLandmark.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LWFyaWErbGFuZG1hcmtAMy4wLjAtX2Y5MDQ5MGQyNWI4YTVhMTMzNzczNmJiODY0NmUwMGMxL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS9sYW5kbWFyay9kaXN0L3VzZUxhbmRtYXJrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvSDtBQUN4QztBQUM4Qjs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVGQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILEtBQUs7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLEtBQUssY0FBYyxNQUFNO0FBQzVHO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVGQUF1RjtBQUNuRztBQUNBO0FBQ0Esd0RBQXdELDJDQUFlO0FBQ3ZFLDJCQUEyQiw4Q0FBa0I7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBa0I7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVEsOERBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHeUk7QUFDekkiLCJzb3VyY2VzIjpbIkU6XFxDb2RpZ29fV0JNWFxcd2JteFxcd2JteC1vZmljaWFsXFxub2RlX21vZHVsZXNcXC5wbnBtXFxAcmVhY3QtYXJpYStsYW5kbWFya0AzLjAuMC1fZjkwNDkwZDI1YjhhNWExMzM3NzM2YmI4NjQ2ZTAwYzFcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LWFyaWFcXGxhbmRtYXJrXFxkaXN0XFx1c2VMYW5kbWFyay5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTdGF0ZSBhcyAkM3hDd2gkdXNlU3RhdGUsIHVzZUNhbGxiYWNrIGFzICQzeEN3aCR1c2VDYWxsYmFjaywgdXNlRWZmZWN0IGFzICQzeEN3aCR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VMYXlvdXRFZmZlY3QgYXMgJDN4Q3doJHVzZUxheW91dEVmZmVjdH0gZnJvbSBcIkByZWFjdC1hcmlhL3V0aWxzXCI7XG5pbXBvcnQge3VzZVN5bmNFeHRlcm5hbFN0b3JlIGFzICQzeEN3aCR1c2VTeW5jRXh0ZXJuYWxTdG9yZX0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbi8vIEluY3JlbWVudCB0aGlzIHZlcnNpb24gbnVtYmVyIHdoZW5ldmVyIHRoZVxuLy8gTGFuZG1hcmtNYW5hZ2VyQXBpIG9yIExhbmRtYXJrIGludGVyZmFjZXMgY2hhbmdlLlxuY29uc3QgJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJExBTkRNQVJLX0FQSV9WRVJTSU9OID0gMTtcbi8vIFN5bWJvbCB1bmRlciB3aGljaCB0aGUgc2luZ2xldG9uIGxhbmRtYXJrIG1hbmFnZXIgaW5zdGFuY2UgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LlxuY29uc3QgJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGxhbmRtYXJrU3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3QtYXJpYS1sYW5kbWFyay1tYW5hZ2VyJyk7XG5mdW5jdGlvbiAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkc3Vic2NyaWJlKGZuKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhY3QtYXJpYS1sYW5kbWFyay1tYW5hZ2VyLWNoYW5nZScsIGZuKTtcbiAgICByZXR1cm4gKCk9PmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlYWN0LWFyaWEtbGFuZG1hcmstbWFuYWdlci1jaGFuZ2UnLCBmbik7XG59XG5mdW5jdGlvbiAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkZ2V0TGFuZG1hcmtNYW5hZ2VyKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgICAvLyBSZXVzZSBhbiBleGlzdGluZyBpbnN0YW5jZSBpZiBpdCBoYXMgdGhlIHNhbWUgb3IgZ3JlYXRlciB2ZXJzaW9uLlxuICAgIGxldCBpbnN0YW5jZSA9IGRvY3VtZW50WyRhODYyMDdjNWQ3ZjdlMWZiJHZhciRsYW5kbWFya1N5bWJvbF07XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnZlcnNpb24gPj0gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJExBTkRNQVJLX0FQSV9WRVJTSU9OKSByZXR1cm4gaW5zdGFuY2U7XG4gICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYSBuZXcgaW5zdGFuY2UgYW5kIGRpc3BhdGNoIGFuIGV2ZW50IHNvIGFueXRoaW5nIHVzaW5nIHRoZSBleGlzdGluZ1xuICAgIC8vIGluc3RhbmNlIHVwZGF0ZXMgYW5kIHJlLXJlZ2lzdGVycyB0aGVpciBsYW5kbWFya3Mgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICBkb2N1bWVudFskYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkbGFuZG1hcmtTeW1ib2xdID0gbmV3ICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRMYW5kbWFya01hbmFnZXIoKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncmVhY3QtYXJpYS1sYW5kbWFyay1tYW5hZ2VyLWNoYW5nZScpKTtcbiAgICByZXR1cm4gZG9jdW1lbnRbJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGxhbmRtYXJrU3ltYm9sXTtcbn1cbi8vIFN1YnNjcmliZXMgYSBSZWFjdCBjb21wb25lbnQgdG8gdGhlIGN1cnJlbnQgbGFuZG1hcmsgbWFuYWdlciBpbnN0YW5jZS5cbmZ1bmN0aW9uICRhODYyMDdjNWQ3ZjdlMWZiJHZhciR1c2VMYW5kbWFya01hbmFnZXIoKSB7XG4gICAgcmV0dXJuICgwLCAkM3hDd2gkdXNlU3luY0V4dGVybmFsU3RvcmUpKCRhODYyMDdjNWQ3ZjdlMWZiJHZhciRzdWJzY3JpYmUsICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRnZXRMYW5kbWFya01hbmFnZXIsICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRnZXRMYW5kbWFya01hbmFnZXIpO1xufVxuY2xhc3MgJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJExhbmRtYXJrTWFuYWdlciB7XG4gICAgc2V0dXBJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMaXN0ZW5pbmcpIHJldHVybjtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuZjZIYW5kbGVyLCB7XG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5mb2N1c2luSGFuZGxlciwge1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLmZvY3Vzb3V0SGFuZGxlciwge1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pc0xpc3RlbmluZyA9IHRydWU7XG4gICAgfVxuICAgIHRlYXJkb3duSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0xpc3RlbmluZyB8fCB0aGlzLmxhbmRtYXJrcy5sZW5ndGggPiAwIHx8IHRoaXMucmVmQ291bnQgPiAwKSByZXR1cm47XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmY2SGFuZGxlciwge1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuZm9jdXNpbkhhbmRsZXIsIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5mb2N1c291dEhhbmRsZXIsIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9jdXNMYW5kbWFyayhsYW5kbWFyaywgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpc19sYW5kbWFya3NfZmluZF9mb2N1cywgX3RoaXNfbGFuZG1hcmtzX2ZpbmQ7XG4gICAgICAgIChfdGhpc19sYW5kbWFya3NfZmluZCA9IHRoaXMubGFuZG1hcmtzLmZpbmQoKGwpPT5sLnJlZi5jdXJyZW50ID09PSBsYW5kbWFyaykpID09PSBudWxsIHx8IF90aGlzX2xhbmRtYXJrc19maW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXNfbGFuZG1hcmtzX2ZpbmRfZm9jdXMgPSBfdGhpc19sYW5kbWFya3NfZmluZC5mb2N1cykgPT09IG51bGwgfHwgX3RoaXNfbGFuZG1hcmtzX2ZpbmRfZm9jdXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2xhbmRtYXJrc19maW5kX2ZvY3VzLmNhbGwoX3RoaXNfbGFuZG1hcmtzX2ZpbmQsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm4gc2V0IG9mIGxhbmRtYXJrcyB3aXRoIGEgc3BlY2lmaWMgcm9sZS5cbiAgICovIGdldExhbmRtYXJrc0J5Um9sZShyb2xlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMubGFuZG1hcmtzLmZpbHRlcigobCk9Pmwucm9sZSA9PT0gcm9sZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJuIGZpcnN0IGxhbmRtYXJrIHdpdGggYSBzcGVjaWZpYyByb2xlLlxuICAgKi8gZ2V0TGFuZG1hcmtCeVJvbGUocm9sZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYW5kbWFya3MuZmluZCgobCk9Pmwucm9sZSA9PT0gcm9sZSk7XG4gICAgfVxuICAgIGFkZExhbmRtYXJrKG5ld0xhbmRtYXJrKSB7XG4gICAgICAgIHRoaXMuc2V0dXBJZk5lZWRlZCgpO1xuICAgICAgICBpZiAodGhpcy5sYW5kbWFya3MuZmluZCgobGFuZG1hcmspPT5sYW5kbWFyay5yZWYgPT09IG5ld0xhbmRtYXJrLnJlZikgfHwgIW5ld0xhbmRtYXJrLnJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmxhbmRtYXJrcy5maWx0ZXIoKGxhbmRtYXJrKT0+bGFuZG1hcmsucm9sZSA9PT0gJ21haW4nKS5sZW5ndGggPiAxKSBjb25zb2xlLmVycm9yKCdQYWdlIGNhbiBjb250YWluIG5vIG1vcmUgdGhhbiBvbmUgbGFuZG1hcmsgd2l0aCB0aGUgcm9sZSBcIm1haW5cIi4nKTtcbiAgICAgICAgaWYgKHRoaXMubGFuZG1hcmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5sYW5kbWFya3MgPSBbXG4gICAgICAgICAgICAgICAgbmV3TGFuZG1hcmtcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB0aGlzLmNoZWNrTGFiZWxzKG5ld0xhbmRtYXJrLnJvbGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJpbmFyeSBzZWFyY2ggdG8gaW5zZXJ0IG5ldyBsYW5kbWFyayBiYXNlZCBvbiBwb3NpdGlvbiBpbiBkb2N1bWVudCByZWxhdGl2ZSB0byBleGlzdGluZyBsYW5kbWFya3MuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL2NvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmxhbmRtYXJrcy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZShzdGFydCA8PSBlbmQpe1xuICAgICAgICAgICAgbGV0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgICAgICAgbGV0IGNvbXBhcmVkUG9zaXRpb24gPSBuZXdMYW5kbWFyay5yZWYuY3VycmVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmxhbmRtYXJrc1ttaWRdLnJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIGxldCBpc05ld0FmdGVyRXhpc3RpbmcgPSBCb29sZWFuKGNvbXBhcmVkUG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyB8fCBjb21wYXJlZFBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyk7XG4gICAgICAgICAgICBpZiAoaXNOZXdBZnRlckV4aXN0aW5nKSBzdGFydCA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIGVuZCA9IG1pZCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYW5kbWFya3Muc3BsaWNlKHN0YXJ0LCAwLCBuZXdMYW5kbWFyayk7XG4gICAgICAgIHRoaXMuY2hlY2tMYWJlbHMobmV3TGFuZG1hcmsucm9sZSk7XG4gICAgfVxuICAgIHVwZGF0ZUxhbmRtYXJrKGxhbmRtYXJrKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubGFuZG1hcmtzLmZpbmRJbmRleCgobCk9PmwucmVmID09PSBsYW5kbWFyay5yZWYpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5sYW5kbWFya3NbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMubGFuZG1hcmtzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAuLi5sYW5kbWFya1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tMYWJlbHModGhpcy5sYW5kbWFya3NbaW5kZXhdLnJvbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUxhbmRtYXJrKHJlZikge1xuICAgICAgICB0aGlzLmxhbmRtYXJrcyA9IHRoaXMubGFuZG1hcmtzLmZpbHRlcigobGFuZG1hcmspPT5sYW5kbWFyay5yZWYgIT09IHJlZik7XG4gICAgICAgIHRoaXMudGVhcmRvd25JZk5lZWRlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogV2FybiBpZiB0aGVyZSBhcmUgMisgbGFuZG1hcmtzIHdpdGggdGhlIHNhbWUgcm9sZSBidXQgbm8gbGFiZWwuXG4gICAqIExhYmVscyBmb3IgbGFuZG1hcmtzIHdpdGggdGhlIHNhbWUgcm9sZSBtdXN0IGFsc28gYmUgdW5pcXVlLlxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wcmFjdGljZXMvbGFuZG1hcmstcmVnaW9ucy8uXG4gICAqLyBjaGVja0xhYmVscyhyb2xlKSB7XG4gICAgICAgIGxldCBsYW5kbWFya3NXaXRoUm9sZSA9IHRoaXMuZ2V0TGFuZG1hcmtzQnlSb2xlKHJvbGUpO1xuICAgICAgICBpZiAobGFuZG1hcmtzV2l0aFJvbGUuc2l6ZSA+IDEpIHtcbiAgICAgICAgICAgIGxldCBkdXBsaWNhdGVzV2l0aG91dExhYmVsID0gW1xuICAgICAgICAgICAgICAgIC4uLmxhbmRtYXJrc1dpdGhSb2xlXG4gICAgICAgICAgICBdLmZpbHRlcigobGFuZG1hcmspPT4hbGFuZG1hcmsubGFiZWwpO1xuICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZXNXaXRob3V0TGFiZWwubGVuZ3RoID4gMCkgY29uc29sZS53YXJuKGBQYWdlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgbGFuZG1hcmsgd2l0aCB0aGUgJyR7cm9sZX0nIHJvbGUuIElmIHR3byBvciBtb3JlIGxhbmRtYXJrcyBvbiBhIHBhZ2Ugc2hhcmUgdGhlIHNhbWUgcm9sZSwgYWxsIG11c3QgYmUgbGFiZWxlZCB3aXRoIGFuIGFyaWEtbGFiZWwgb3IgYXJpYS1sYWJlbGxlZGJ5IGF0dHJpYnV0ZTogYCwgZHVwbGljYXRlc1dpdGhvdXRMYWJlbC5tYXAoKGxhbmRtYXJrKT0+bGFuZG1hcmsucmVmLmN1cnJlbnQpKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmxhbmRtYXJrc1dpdGhSb2xlXG4gICAgICAgICAgICAgICAgXS5tYXAoKGxhbmRtYXJrKT0+bGFuZG1hcmsubGFiZWwpO1xuICAgICAgICAgICAgICAgIGxldCBkdXBsaWNhdGVMYWJlbHMgPSBsYWJlbHMuZmlsdGVyKChpdGVtLCBpbmRleCk9PmxhYmVscy5pbmRleE9mKGl0ZW0pICE9PSBpbmRleCk7XG4gICAgICAgICAgICAgICAgZHVwbGljYXRlTGFiZWxzLmZvckVhY2goKGxhYmVsKT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFBhZ2UgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBsYW5kbWFyayB3aXRoIHRoZSAnJHtyb2xlfScgcm9sZSBhbmQgJyR7bGFiZWx9JyBsYWJlbC4gSWYgdHdvIG9yIG1vcmUgbGFuZG1hcmtzIG9uIGEgcGFnZSBzaGFyZSB0aGUgc2FtZSByb2xlLCB0aGV5IG11c3QgaGF2ZSB1bmlxdWUgbGFiZWxzOiBgLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5sYW5kbWFya3NXaXRoUm9sZVxuICAgICAgICAgICAgICAgICAgICBdLmZpbHRlcigobGFuZG1hcmspPT5sYW5kbWFyay5sYWJlbCA9PT0gbGFiZWwpLm1hcCgobGFuZG1hcmspPT5sYW5kbWFyay5yZWYuY3VycmVudCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXQgdGhlIGxhbmRtYXJrIHRoYXQgaXMgdGhlIGNsb3Nlc3QgcGFyZW50IGluIHRoZSBET00uXG4gICAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vIHBhcmVudCBpcyBhIGxhbmRtYXJrLlxuICAgKi8gY2xvc2VzdExhbmRtYXJrKGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGxhbmRtYXJrTWFwID0gbmV3IE1hcCh0aGlzLmxhbmRtYXJrcy5tYXAoKGwpPT5bXG4gICAgICAgICAgICAgICAgbC5yZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBsXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIGxldCBjdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHdoaWxlKGN1cnJlbnRFbGVtZW50ICYmICFsYW5kbWFya01hcC5oYXMoY3VycmVudEVsZW1lbnQpICYmIGN1cnJlbnRFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGN1cnJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQpY3VycmVudEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICByZXR1cm4gbGFuZG1hcmtNYXAuZ2V0KGN1cnJlbnRFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldHMgdGhlIG5leHQgbGFuZG1hcmssIGluIERPTSBmb2N1cyBvcmRlciwgb3IgcHJldmlvdXMgaWYgYmFja3dhcmRzIGlzIHNwZWNpZmllZC5cbiAgICogSWYgbGFzdCBsYW5kbWFyaywgbmV4dCBzaG91bGQgYmUgdGhlIGZpcnN0IGxhbmRtYXJrLlxuICAgKiBJZiBub3QgaW5zaWRlIGEgbGFuZG1hcmssIHdpbGwgcmV0dXJuIGZpcnN0IGxhbmRtYXJrLlxuICAgKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gbGFuZG1hcmtzLlxuICAgKi8gZ2V0TmV4dExhbmRtYXJrKGVsZW1lbnQsIHsgYmFja3dhcmQ6IGJhY2t3YXJkIH0pIHtcbiAgICAgICAgdmFyIF90aGlzX2xhbmRtYXJrc19uZXh0TGFuZG1hcmtJbmRleF9yZWZfY3VycmVudDtcbiAgICAgICAgbGV0IGN1cnJlbnRMYW5kbWFyayA9IHRoaXMuY2xvc2VzdExhbmRtYXJrKGVsZW1lbnQpO1xuICAgICAgICBsZXQgbmV4dExhbmRtYXJrSW5kZXggPSBiYWNrd2FyZCA/IHRoaXMubGFuZG1hcmtzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICBpZiAoY3VycmVudExhbmRtYXJrKSBuZXh0TGFuZG1hcmtJbmRleCA9IHRoaXMubGFuZG1hcmtzLmluZGV4T2YoY3VycmVudExhbmRtYXJrKSArIChiYWNrd2FyZCA/IC0xIDogMSk7XG4gICAgICAgIGxldCB3cmFwSWZOZWVkZWQgPSAoKT0+e1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSBsYW5kbWFyayBzZXF1ZW5jZSwgZmlyZSBhIGN1c3RvbSBldmVudCB0aGF0IGNhbiBiZSBsaXN0ZW5lZCBmb3IgYnkgYXBwbGljYXRpb25zLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBldmVudCBpcyBjYW5jZWxlZCwgd2UgcmV0dXJuIGltbWVkaWF0ZWx5LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBsYW5kbWFyayBuYXZpZ2F0aW9uIGFjcm9zcyBpZnJhbWVzLlxuICAgICAgICAgICAgaWYgKG5leHRMYW5kbWFya0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncmVhY3QtYXJpYS1sYW5kbWFyay1uYXZpZ2F0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBuZXh0TGFuZG1hcmtJbmRleCA9IHRoaXMubGFuZG1hcmtzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRMYW5kbWFya0luZGV4ID49IHRoaXMubGFuZG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncmVhY3QtYXJpYS1sYW5kbWFyay1uYXZpZ2F0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIG5leHRMYW5kbWFya0luZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZG1hcmtJbmRleCA8IDAgfHwgbmV4dExhbmRtYXJrSW5kZXggPj0gdGhpcy5sYW5kbWFya3MubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHdyYXBJZk5lZWRlZCgpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBTa2lwIG92ZXIgaGlkZGVuIGxhbmRtYXJrcy5cbiAgICAgICAgbGV0IGkgPSBuZXh0TGFuZG1hcmtJbmRleDtcbiAgICAgICAgd2hpbGUoKF90aGlzX2xhbmRtYXJrc19uZXh0TGFuZG1hcmtJbmRleF9yZWZfY3VycmVudCA9IHRoaXMubGFuZG1hcmtzW25leHRMYW5kbWFya0luZGV4XS5yZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3RoaXNfbGFuZG1hcmtzX25leHRMYW5kbWFya0luZGV4X3JlZl9jdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19sYW5kbWFya3NfbmV4dExhbmRtYXJrSW5kZXhfcmVmX2N1cnJlbnQuY2xvc2VzdCgnW2FyaWEtaGlkZGVuPXRydWVdJykpe1xuICAgICAgICAgICAgbmV4dExhbmRtYXJrSW5kZXggKz0gYmFja3dhcmQgPyAtMSA6IDE7XG4gICAgICAgICAgICBpZiAod3JhcElmTmVlZGVkKCkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobmV4dExhbmRtYXJrSW5kZXggPT09IGkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhbmRtYXJrc1tuZXh0TGFuZG1hcmtJbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgKiBMb29rIGF0IG5leHQgbGFuZG1hcmsuIElmIGFuIGVsZW1lbnQgd2FzIHByZXZpb3VzbHkgZm9jdXNlZCBpbnNpZGUsIHJlc3RvcmUgZm9jdXMgdGhlcmUuXG4gICAqIElmIG5vdCwgZm9jdXMgdGhlIGxhbmRtYXJrIGl0c2VsZi5cbiAgICogSWYgbm8gbGFuZG1hcmtzIGF0IGFsbCwgb3Igbm9uZSB3aXRoIGZvY3VzYWJsZSBlbGVtZW50cywgZG9uJ3QgbW92ZSBmb2N1cy5cbiAgICovIGY2SGFuZGxlcihlKSB7XG4gICAgICAgIGlmIChlLmtleSA9PT0gJ0Y2Jykge1xuICAgICAgICAgICAgLy8gSWYgYWx0IGtleSBwcmVzc2VkLCBmb2N1cyBtYWluIGxhbmRtYXJrLCBvdGhlcndpc2UgbmF2aWdhdGUgZm9yd2FyZCBvciBiYWNrd2FyZCBiYXNlZCBvbiBzaGlmdCBrZXkuXG4gICAgICAgICAgICBsZXQgaGFuZGxlZCA9IGUuYWx0S2V5ID8gdGhpcy5mb2N1c01haW4oKSA6IHRoaXMubmF2aWdhdGUoZS50YXJnZXQsIGUuc2hpZnRLZXkpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c01haW4oKSB7XG4gICAgICAgIGxldCBtYWluID0gdGhpcy5nZXRMYW5kbWFya0J5Um9sZSgnbWFpbicpO1xuICAgICAgICBpZiAobWFpbiAmJiBtYWluLnJlZi5jdXJyZW50ICYmIGRvY3VtZW50LmNvbnRhaW5zKG1haW4ucmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzTGFuZG1hcmsobWFpbi5yZWYuY3VycmVudCwgJ2ZvcndhcmQnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmF2aWdhdGUoZnJvbSwgYmFja3dhcmQpIHtcbiAgICAgICAgbGV0IG5leHRMYW5kbWFyayA9IHRoaXMuZ2V0TmV4dExhbmRtYXJrKGZyb20sIHtcbiAgICAgICAgICAgIGJhY2t3YXJkOiBiYWNrd2FyZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFuZXh0TGFuZG1hcmspIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBwcmV2aW91c2x5IGZvY3VzZWQgaW4gdGhlIG5leHQgbGFuZG1hcmssIHRoZW4gcmV0dXJuIGZvY3VzIHRvIGl0XG4gICAgICAgIGlmIChuZXh0TGFuZG1hcmsubGFzdEZvY3VzZWQpIHtcbiAgICAgICAgICAgIGxldCBsYXN0Rm9jdXNlZCA9IG5leHRMYW5kbWFyay5sYXN0Rm9jdXNlZDtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGxhc3RGb2N1c2VkKSkge1xuICAgICAgICAgICAgICAgIGxhc3RGb2N1c2VkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBmb2N1cyB0aGUgbGFuZG1hcmsgaXRzZWxmXG4gICAgICAgIGlmIChuZXh0TGFuZG1hcmsucmVmLmN1cnJlbnQgJiYgZG9jdW1lbnQuY29udGFpbnMobmV4dExhbmRtYXJrLnJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0xhbmRtYXJrKG5leHRMYW5kbWFyay5yZWYuY3VycmVudCwgYmFja3dhcmQgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgbGFzdEZvY3VzZWQgZm9yIGEgbGFuZG1hcmssIGlmIGZvY3VzIGlzIG1vdmVkIHdpdGhpbiB0aGF0IGxhbmRtYXJrLlxuICAgKiBMZXRzIHRoZSBsYXN0IGZvY3VzZWQgbGFuZG1hcmsga25vdyBpdCB3YXMgYmx1cnJlZCBpZiBzb21ldGhpbmcgZWxzZSBpcyBmb2N1c2VkLlxuICAgKi8gZm9jdXNpbkhhbmRsZXIoZSkge1xuICAgICAgICBsZXQgY3VycmVudExhbmRtYXJrID0gdGhpcy5jbG9zZXN0TGFuZG1hcmsoZS50YXJnZXQpO1xuICAgICAgICBpZiAoY3VycmVudExhbmRtYXJrICYmIGN1cnJlbnRMYW5kbWFyay5yZWYuY3VycmVudCAhPT0gZS50YXJnZXQpIHRoaXMudXBkYXRlTGFuZG1hcmsoe1xuICAgICAgICAgICAgcmVmOiBjdXJyZW50TGFuZG1hcmsucmVmLFxuICAgICAgICAgICAgbGFzdEZvY3VzZWQ6IGUudGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcHJldmlvdXNGb2N1c2VkRWxlbWVudCA9IGUucmVsYXRlZFRhcmdldDtcbiAgICAgICAgaWYgKHByZXZpb3VzRm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBjbG9zZXN0UHJldmlvdXNMYW5kbWFyayA9IHRoaXMuY2xvc2VzdExhbmRtYXJrKHByZXZpb3VzRm9jdXNlZEVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RQcmV2aW91c0xhbmRtYXJrICYmIGNsb3Nlc3RQcmV2aW91c0xhbmRtYXJrLnJlZi5jdXJyZW50ID09PSBwcmV2aW91c0ZvY3VzZWRFbGVtZW50KSBjbG9zZXN0UHJldmlvdXNMYW5kbWFyay5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIFRyYWNrIGlmIHRoZSBmb2N1cyBpcyBsb3N0IHRvIHRoZSBib2R5LiBJZiBpdCBpcywgZG8gY2xlYW51cCBvbiB0aGUgbGFuZG1hcmsgdGhhdCBsYXN0IGhhZCBmb2N1cy5cbiAgICovIGZvY3Vzb3V0SGFuZGxlcihlKSB7XG4gICAgICAgIGxldCBwcmV2aW91c0ZvY3VzZWRFbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgICAgIGxldCBuZXh0Rm9jdXNlZEVsZW1lbnQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIC8vIHRoZSA9PT0gZG9jdW1lbnQgc2VlbXMgdG8gYmUgYSBqZXN0IHRoaW5nIGZvciBmb2N1cyB0byBnbyB0aGVyZSBvbiBnZW5lcmljIGJsdXIgZXZlbnQgc3VjaCBhcyBsYW5kbWFyay5ibHVyKCk7XG4gICAgICAgIC8vIGJyb3dzZXJzIGFwcGVhciB0byBzZW5kIGZvY3VzIGluc3RlYWQgdG8gZG9jdW1lbnQuYm9keSBhbmQgdGhlIHJlbGF0ZWRUYXJnZXQgaXMgbnVsbCB3aGVuIHRoYXQgaGFwcGVuc1xuICAgICAgICBpZiAoIW5leHRGb2N1c2VkRWxlbWVudCB8fCBuZXh0Rm9jdXNlZEVsZW1lbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICBsZXQgY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsgPSB0aGlzLmNsb3Nlc3RMYW5kbWFyayhwcmV2aW91c0ZvY3VzZWRFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UHJldmlvdXNMYW5kbWFyayAmJiBjbG9zZXN0UHJldmlvdXNMYW5kbWFyay5yZWYuY3VycmVudCA9PT0gcHJldmlvdXNGb2N1c2VkRWxlbWVudCkgY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUxhbmRtYXJrQ29udHJvbGxlcigpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcztcbiAgICAgICAgaW5zdGFuY2UucmVmQ291bnQrKztcbiAgICAgICAgaW5zdGFuY2Uuc2V0dXBJZk5lZWRlZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmF2aWdhdGUgKGRpcmVjdGlvbiwgb3B0cykge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mcm9tKSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5uYXZpZ2F0ZShlbGVtZW50LCBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzTmV4dCAob3B0cykge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mcm9tKSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5uYXZpZ2F0ZShlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXNQcmV2aW91cyAob3B0cykge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mcm9tKSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5uYXZpZ2F0ZShlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1c01haW4gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5mb2N1c01haW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVmQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudGVhcmRvd25JZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlckxhbmRtYXJrKGxhbmRtYXJrKSB7XG4gICAgICAgIGlmICh0aGlzLmxhbmRtYXJrcy5maW5kKChsKT0+bC5yZWYgPT09IGxhbmRtYXJrLnJlZikpIHRoaXMudXBkYXRlTGFuZG1hcmsobGFuZG1hcmspO1xuICAgICAgICBlbHNlIHRoaXMuYWRkTGFuZG1hcmsobGFuZG1hcmspO1xuICAgICAgICByZXR1cm4gKCk9PnRoaXMucmVtb3ZlTGFuZG1hcmsobGFuZG1hcmsucmVmKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5sYW5kbWFya3MgPSBbXTtcbiAgICAgICAgdGhpcy5pc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJExBTkRNQVJLX0FQSV9WRVJTSU9OO1xuICAgICAgICB0aGlzLmY2SGFuZGxlciA9IHRoaXMuZjZIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZm9jdXNpbkhhbmRsZXIgPSB0aGlzLmZvY3VzaW5IYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZm9jdXNvdXRIYW5kbGVyID0gdGhpcy5mb2N1c291dEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkYTg2MjA3YzVkN2Y3ZTFmYiRleHBvcnQkZjUwMTUxZGJkNTFjZDFkOSgpIHtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgbGFuZG1hcmsgbWFuYWdlciBhbmQgY3JlYXRlIGEgY29udHJvbGxlciB1c2luZyBpdC5cbiAgICBsZXQgaW5zdGFuY2UgPSAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkZ2V0TGFuZG1hcmtNYW5hZ2VyKCk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBpbnN0YW5jZSA9PT0gbnVsbCB8fCBpbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFuY2UuY3JlYXRlTGFuZG1hcmtDb250cm9sbGVyKCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlID0gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJHN1YnNjcmliZSgoKT0+e1xuICAgICAgICAvLyBJZiB0aGUgbGFuZG1hcmsgbWFuYWdlciBjaGFuZ2VzLCBkaXNwb3NlIHRoZSBvbGRcbiAgICAgICAgLy8gY29udHJvbGxlciBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgY29udHJvbGxlciA9PT0gbnVsbCB8fCBjb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgaW5zdGFuY2UgPSAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkZ2V0TGFuZG1hcmtNYW5hZ2VyKCk7XG4gICAgICAgIGNvbnRyb2xsZXIgPSBpbnN0YW5jZSA9PT0gbnVsbCB8fCBpbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFuY2UuY3JlYXRlTGFuZG1hcmtDb250cm9sbGVyKCk7XG4gICAgfSk7XG4gICAgLy8gUmV0dXJuIGEgd3JhcHBlciB0aGF0IHByb3hpZXMgcmVxdWVzdHMgdG8gdGhlIGN1cnJlbnQgY29udHJvbGxlciBpbnN0YW5jZS5cbiAgICByZXR1cm4ge1xuICAgICAgICBuYXZpZ2F0ZSAoZGlyZWN0aW9uLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5uYXZpZ2F0ZShkaXJlY3Rpb24sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c05leHQgKG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmZvY3VzTmV4dChvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNQcmV2aW91cyAob3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZm9jdXNQcmV2aW91cyhvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNNYWluICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmZvY3VzTWFpbigpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwb3NlICgpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPT09IG51bGwgfHwgY29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udHJvbGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgY29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiAkYTg2MjA3YzVkN2Y3ZTFmYiRleHBvcnQkNGNjNjMyNTg0ZmQ4N2ZhZShwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyByb2xlOiByb2xlLCAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCwgJ2FyaWEtbGFiZWxsZWRieSc6IGFyaWFMYWJlbGxlZGJ5LCBmb2N1czogZm9jdXMgfSA9IHByb3BzO1xuICAgIGxldCBtYW5hZ2VyID0gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJHVzZUxhbmRtYXJrTWFuYWdlcigpO1xuICAgIGxldCBsYWJlbCA9IGFyaWFMYWJlbCB8fCBhcmlhTGFiZWxsZWRieTtcbiAgICBsZXQgW2lzTGFuZG1hcmtGb2N1c2VkLCBzZXRJc0xhbmRtYXJrRm9jdXNlZF0gPSAoMCwgJDN4Q3doJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IGRlZmF1bHRGb2N1cyA9ICgwLCAkM3hDd2gkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldElzTGFuZG1hcmtGb2N1c2VkKHRydWUpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0SXNMYW5kbWFya0ZvY3VzZWRcbiAgICBdKTtcbiAgICBsZXQgYmx1ciA9ICgwLCAkM3hDd2gkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldElzTGFuZG1hcmtGb2N1c2VkKGZhbHNlKTtcbiAgICB9LCBbXG4gICAgICAgIHNldElzTGFuZG1hcmtGb2N1c2VkXG4gICAgXSk7XG4gICAgKDAsICQzeEN3aCR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChtYW5hZ2VyKSByZXR1cm4gbWFuYWdlci5yZWdpc3RlckxhbmRtYXJrKHtcbiAgICAgICAgICAgIHJlZjogcmVmLFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgcm9sZTogcm9sZSxcbiAgICAgICAgICAgIGZvY3VzOiBmb2N1cyB8fCBkZWZhdWx0Rm9jdXMsXG4gICAgICAgICAgICBibHVyOiBibHVyXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgbWFuYWdlcixcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIHJlZixcbiAgICAgICAgcm9sZSxcbiAgICAgICAgZm9jdXMsXG4gICAgICAgIGRlZmF1bHRGb2N1cyxcbiAgICAgICAgYmx1clxuICAgIF0pO1xuICAgICgwLCAkM3hDd2gkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICB2YXIgX3JlZl9jdXJyZW50O1xuICAgICAgICBpZiAoaXNMYW5kbWFya0ZvY3VzZWQpIChfcmVmX2N1cnJlbnQgPSByZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlZl9jdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVmX2N1cnJlbnQuZm9jdXMoKTtcbiAgICB9LCBbXG4gICAgICAgIGlzTGFuZG1hcmtGb2N1c2VkLFxuICAgICAgICByZWZcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsYW5kbWFya1Byb3BzOiB7XG4gICAgICAgICAgICByb2xlOiByb2xlLFxuICAgICAgICAgICAgdGFiSW5kZXg6IGlzTGFuZG1hcmtGb2N1c2VkID8gLTEgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBhcmlhTGFiZWxsZWRieVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5leHBvcnQgeyRhODYyMDdjNWQ3ZjdlMWZiJGV4cG9ydCRmNTAxNTFkYmQ1MWNkMWQ5IGFzIGNyZWF0ZUxhbmRtYXJrQ29udHJvbGxlciwgJGE4NjIwN2M1ZDdmN2UxZmIkZXhwb3J0JDRjYzYzMjU4NGZkODdmYWUgYXMgdXNlTGFuZG1hcmt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTGFuZG1hcmsubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-aria+landmark@3.0.0-_f90490d25b8a5a1337736bb8646e00c1/node_modules/@react-aria/landmark/dist/useLandmark.mjs\n");

/***/ })

};
;